% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/single_linkage.R
\name{distmx_cluster}
\alias{distmx_cluster}
\title{Single linkage clustering at multiple thresholds from a sparse distance
matrix}
\usage{
distmx_cluster(
  distmx,
  names,
  threshold_config,
  clust_config = clust_index(),
  parallel_config = parallel_concurrent(1),
  output_type = c("matrix", "hclust"),
  which = NULL,
  verbose = FALSE,
  by_name = FALSE
)
}
\arguments{
\item{distmx}{(\code{character} filename) The name of the file (or, e.g., a named
pipe) from which to read the sparse distance matrix. The matrix should be
a white-space delimited text file, with three values per line: id1 id2 dist,
where id1 and id2 are indices of the objects to be clustered, and dist is the
distance, typically a real number between 0 and 1 (but the algorithm works
for any non-negative distance.)}

\item{names}{(\code{character} vector) Names of the sequences, used for
labeling the columns of the output matrix. Typically, in order to generate
the sparse distance matrix with integer indices, an alternate version of the
input may be used, where the "real" names are replaced with integers. These
are the "real" names.}

\item{threshold_config}{(\code{optimotu_threshold_config} object returned by
\code{\link[=threshold_config]{threshold_config()}} or one of its helper functions) Definition of the
thresholds to use for clustering.}

\item{clust_config}{(\code{optimotu_cluster_config} object returned by
\code{\link[=clust_config]{clust_config()}} or one of its helpers) The clustering algorithm to use; all
algorithms give identical results, but may have different performance
characteristics on different problems.}

\item{parallel_config}{(\code{optimotu_parallel_config} object returned by
\code{\link[=parallel_config]{parallel_config()}} or one of its helpers) The method to use for
parallel clustering. For single-threaded clustering, use the default value
(\code{\link[=parallel_concurrent]{parallel_concurrent()}} with \code{threads = 1}).}

\item{output_type}{(\code{character}) Which type of output to give; one of
\code{"matrix"} or \code{"hclust"}. \code{"matrix"} returns an integer matrix giving
clustering results, where the element in row \code{i} and column \code{j} gives the
0-based index of the first member of the cluster to which sequence \code{j}
belongs when clustered at the \code{i}th clustering threshold. \code{"hclust"} returns
an object as returned by \code{\link[stats:hclust]{stats::hclust()}}, which requires less memory,
especially for large problems. If \code{which} is given, then both \code{output_type}s
instead return a list whose elements are of the chosen type.}

\item{which}{(\code{list} of \code{character} vectors) Instead of performing clustering
on all input sequences, perform independent clustering on subsets of the
sequences defined by the elements of \code{which}. Subsets do not need to be
disjoint (and indeed, if they are it is probably faster to calculate the
distance matrices separately.)}

\item{verbose}{(\code{logical(1)} or \code{integer(1)}) Whether to print progress;
values greater than 1 (or TRUE) print more.}

\item{by_name}{(\code{logical(1)}) If \code{TRUE}, columns "id1" and "id2" in the
distance matrix are string identifiers which should match sequence names
in the \code{names} argument. If \code{FALSE}, they are integer indices starting with
0 for the first sequence in \code{names}.}
}
\value{
An \code{\link[methods:StructureClasses]{integer matrix}} if
\code{output_type=="matrix"}, an \code{\link[stats:hclust]{hclust}} object if
\code{output_type=="hclust"}, or a list of one of these when \code{which} is a list.
}
\description{
This function is designed to reduce CPU and memory requirements
of clustering by doing multiple clustering "jobs" concurrently from the same
sparse distance matrix, which is read once and never kept in memory.  This is
especially useful when the algorithm generating the distance matrix can also
operate in a streaming fashion, so that distance matrices which are too large
to fit in memory, or even to disk, can still be utilized. The motivating
application is clustering biological sequences, but the implementation is
totally agnostic about the nature of the entities it is clustering; it only
needs distances.
}
