% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R, R/seq_distmx.R
\name{seq_distmx_kmer}
\alias{seq_distmx_kmer}
\alias{seq_distmx_prealign}
\alias{seq_distmx}
\alias{seq_distmx_edlib}
\alias{seq_distmx_hamming}
\alias{seq_distmx_wfa2}
\title{Search for the closest match(es) to sequences in a reference database}
\usage{
seq_distmx_kmer(
  seq,
  dist_threshold,
  udist_threshold,
  match = -1L,
  mismatch = 2L,
  gap_open = 10L,
  gap_extend = 1L,
  gap_open2 = 0L,
  gap_extend2 = 0L,
  threads = 1L
)

seq_distmx_prealign(
  seq,
  dist_threshold,
  match = -1L,
  mismatch = 2L,
  gap_open = 10L,
  gap_extend = 1L,
  gap_open2 = 0L,
  gap_extend2 = 0L,
  prealign = TRUE,
  constrain = TRUE,
  threads = 1L
)

seq_distmx(
  seq,
  threshold,
  seq_id = NULL,
  dist_config = dist_wfa2(),
  parallel_config = parallel_concurrent(1),
  verbose = FALSE,
  details = c("none", "gapstats", "cigar"),
  span = c("global", "extension"),
  constrain = TRUE,
  id_is_int = is.data.frame(seq) && "seq_idx" \%in\% names(seq),
  ...
)

seq_distmx_edlib(
  seq,
  threshold,
  details = 0L,
  span = 0L,
  constrain = TRUE,
  threads = 1L,
  verbose = 0L,
  ...
)

seq_distmx_hamming(
  seq,
  threshold,
  min_overlap = 0L,
  ignore_gaps = FALSE,
  threads = 1L,
  verbose = 0L,
  ...
)

seq_distmx_wfa2(
  seq,
  threshold,
  match = -1L,
  mismatch = 2L,
  gap_open = 10L,
  gap_extend = 1L,
  gap_open2 = 0L,
  gap_extend2 = 0L,
  constrain = TRUE,
  threads = 1L,
  verbose = 0L,
  ...
)
}
\arguments{
\item{seq}{(\code{character}, \code{data.frame}, or \code{XStringSet}) DNA sequences to
calculate distances for}

\item{udist_threshold}{(\code{numeric} scalar between 0 and 1) maximum udist
(number of shared kmers / number of kmers in the shorter sequence) for full
alignment.}

\item{match}{(non-negative \code{integer} scalar) score for a match}

\item{mismatch}{(positive \code{integer} scalar) penalty for a mismatch}

\item{gap_open}{(non-negative \code{integer} scalar) penalty for gap opening}

\item{gap_extend}{(positive \code{integer} scalar) penalty for gap extension}

\item{gap_open2}{(non-negative \code{integer} scalar) alternate penalty for gap
opening}

\item{gap_extend2}{(positive \code{integer} scalar) alternate penalty for gap
extension}

\item{prealign}{(\code{logical} flag) if \code{TRUE}, do a prealignment using
edit-distance as alignment score (\verb{match = 0, mismatch = 1, gap_open = 0, gap_extend = 1, gap_open2 = 0, gap_extend2 = 1}) to test feasibility before
aligning with alternate alignment scores. Note that, since pairwise distance
is defined using edit distance, any other set of scores will always result
in a pairwise distance which is equal to or greater than an alignment based
on the edit distance score.}

\item{constrain}{(\code{logical} flag) if \code{TRUE}, the alignment algorithm will
use optimizations that will cause it to exit early if all possible alignments
have a distance greater than the distance threshold. This should not change
the correctness of distance calculations below the threshold, and results in
a large speedup for WFA2 and edlib. It is recommended to use
\code{constrain=FALSE} only to verify that the results do not change.}

\item{threshold}{(\code{numeric} scalar) maximum distance to consider a match, in
[0, 1] where 0 is identical.}

\item{seq_id}{(\code{character} vector) names for the sequences.  If they
are already named, this will replace the names.}

\item{dist_config}{(\code{optimotu_dist_config}) configuration for calculating
distances, as returned by \code{dist_config()} or its helpers.}

\item{parallel_config}{(\code{optimotu_parallel_config}) configuration for
parallel processing, as returned by \code{parallel_config()} or its helpers.}

\item{verbose}{(\code{logical} or \code{integer} scalar) print progress messages.}

\item{details}{(one of "none", "gapstats", or "cigar") if "gapstats", return
#' the gap statistics. If "cigar", return the CIGAR string. Otherwise return
only the score and distance}

\item{span}{(\code{character} string) the span of the alignment; currently
accepted values are "global" and "extension".  The default is "global".}

\item{id_is_int}{(\code{logical} scalar) if \code{TRUE}, the sequence IDs are
parsed as integers, and the returned IDs are integers.
The default is \code{FALSE}.}

\item{...}{passed to methods}

\item{min_overlap}{(\code{integer} scalar) minimum length of overlap between two
sequences (i.e., length after subtracting end gaps in either sequence). If
the required overlap is not met, the distance is returned as 1.}

\item{ignore_gaps}{(\code{logical} flag) if \code{TRUE}, columns containing an internal
gap in one sequence are ignored, i.e. not counted as a mismatch and also not
counted towards the total aligned length. If \code{FALSE}, such columns are
counted as mismatches.  End gaps in either sequence, and internal gaps shared
by both sequences, are always ignored.}
}
\value{
(\code{data.frame}) with columns "seq_id1" and "seq_id2" (\code{character}),
or "seq_idx1" and "seq_idx2" (\code{integer}) if \code{id_is_integer} is \code{TRUE},
"score1" and "dist1" giving the score and distance for the prealignment
stage, if any, and "score2" and "dist2" (\code{numeric}) giving the final score
and distance. If \code{details} is "gapstats", the gap statistics are returned in
columns "align_length", "n_insert", "n_delete", "max_insert", and
"max_delete" (\code{integer}). If \code{details} is "cigar", the CIGAR string is
returned in a column "cigar" (\code{character}).
}
\description{
Search for the closest match(es) to sequences in a reference database
}
