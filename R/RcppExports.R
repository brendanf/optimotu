# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Confusion matrix for a set of "test" partitions vs. a "true" partition
#'
#' One way to analyze the comparison of two different partitions of the same
#' data is to treat it as a binary classification problem operating on pairs
#' of objects, where pairs should be classified as belonging to the same
#' cluster or not.  Then a "true positive" is a pair which belong to the same
#' cluster in both the "test" partition and the "true" partition; a "false
#' positive" is a pair which belongs to the same cluster in the "test"
#' partition but not the "true" partition; a "false negative" is a pair which
#' belongs to the same cluster in the "true" partition but not in the "test"
#' partition; and a "true" negative is a pair which does not belong to the same
#' cluster in either the "test" partition or the "true" partition.
#'
#' This formulation allows various measures of binary classification
#' performance to be applied to the case of clustering.
#'
#' @return (`data.frame` with `m` rows) for each "test" partition, the number
#' of true positives ("`TP`"), false positives ("`FP`"), false negatives
#' ("`FN`"), and true negatives ("`TN`") relative to the "true" partition.
#'
#' @export
#' @inheritParams mutual_information
confusion_matrix <- function(k, c, threads = 1L) {
    .Call(`_optimotu_confusion_matrix`, k, c, threads)
}

#' @export
#' @describeIn confusion_matrix confusion matrix for different references at
#'  each threshold
confusion_matrix2 <- function(k, c, threads = 1L) {
    .Call(`_optimotu_confusion_matrix2`, k, c, threads)
}

distmx_cluster_single <- function(file, seqnames, threshold_config, clust_config, parallel_config, output_type = "matrix", verbose = FALSE, by_name = FALSE) {
    .Call(`_optimotu_distmx_cluster_single`, file, seqnames, threshold_config, clust_config, parallel_config, output_type, verbose, by_name)
}

distmx_cluster_multi <- function(file, seqnames, which, threshold_config, method_config, parallel_config, output_type = "matrix", verbose = FALSE, by_name = FALSE) {
    .Call(`_optimotu_distmx_cluster_multi`, file, seqnames, which, threshold_config, method_config, parallel_config, output_type, verbose, by_name)
}

#' Sparse distance matrix between DNA sequences
#'
#' @name seq_distmx
#'
#' @param seq (`character` vector) DNA sequences to calculate distances for
#' @param dist_threshold (`numeric` scalar) maximum sequence distance (edit
#' distance / alignment length) threshold for reporting
#' @param constrain (`logical` flag) if `TRUE`, the alignment algorithm will
#' use optimizations that will cause it to exit early if the optimal alignment
#' has a distance greater than the distance threshold. This should not change
#' the correctness of distance calculations below the threshold, and results in
#' a large speedup. It is recommended to use `constrain=FALSE` only to verify
#' that the results do not change.
#' @param threads (`integer` count) number of parallel threads to use for
#' computation.
#' @param verbose (`integer` level) verbosity level
#'
#' @return (`data.frame`) a sparse distance matrix; columns are `seq1` and
#' `seq2` for the 0-based indices of two sequences; `score1` and `score2` are
#' the optimal alignment score for the two sequences in the "prealignment" (if
#' any) and "alignment" stages; `dist1` and `dist2` are the corresponding
#' sequence distances.
#'
#' @export
#' @rdname seq_distmx
seq_distmx_edlib <- function(seq, dist_threshold, details = 0L, span = 0L, constrain = TRUE, threads = 1L, verbose = 0L) {
    .Call(`_optimotu_seq_distmx_edlib`, seq, dist_threshold, details, span, constrain, threads, verbose)
}

#' Get the names of reads in a FASTQ file
#' @param x (`character`) FASTQ file path, optionally gzipped.
#' @return (`character`) Read names.
fastq_names <- function(x) {
    .Call(`_optimotu_fastq_names`, x)
}

#' Size of the intersection between two sorted sets
#'
#' This implementation is much faster that `length(intersect(c, k))`. However
#' it assumes (without checking!) that the sets are sorted.
#'
#' @param c (sorted `integer` or ` character` vector) the first set to compare
#' @param k (sorted `integer` or ` character` vector) the second set to compare
#'
#' @return (`integer` count) the number of elements which occur in both sets
#' @export
intersect_length <- function(c, k) {
    .Call(`_optimotu_intersect_length`, c, k)
}

#' @export
#' @rdname intersect_length
intersect_length_string <- function(c, k) {
    .Call(`_optimotu_intersect_length_string`, c, k)
}

inner_fmeasure <- function(cj, kpartition, nk) {
    .Call(`_optimotu_inner_fmeasure`, cj, kpartition, nk)
}

fmeasure_list <- function(k, c, ncpu = 1L) {
    .Call(`_optimotu_fmeasure_list`, k, c, ncpu)
}

fmeasure_matrix <- function(k, c, ncpu = 1L) {
    .Call(`_optimotu_fmeasure_matrix`, k, c, ncpu)
}

#' @param udist_threshold (`numeric` scalar between 0 and 1) maximum udist
#' (number of shared kmers / number of kmers in the shorter sequence) for full
#' alignment.
#' @export
#' @rdname seq_distmx
seq_distmx_kmer <- function(seq, dist_threshold, udist_threshold, match = -1L, mismatch = 2L, gap_open = 10L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 0L, threads = 1L) {
    .Call(`_optimotu_seq_distmx_kmer`, seq, dist_threshold, udist_threshold, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2, threads)
}

#' Calculate similarity for a set of alternate "test" partitions vs. a "true" partition
#'
#' @param k (`m` x `n` `integer` matrix) `m` alternative "test" partitions; each
#' row gives the cluster assignment for the `n` objects. Objects with the same
#' cluster ID are clustered together. Cluster IDs do not need to be
#' consecutive, and they do not need to correspond between different
#' partitions.
#' @param c (`integer` vector of length `n`) "True" partition of the `n`
#' objects.
#' @param threads (`integer` count) number of parallel threads to use.
#'
#' @return (`numeric` vector of length `m`) The similarity measure between each
#' of the alternative partitions and the "true" partition.
#' @export
mutual_information <- function(k, c, threads = 1L) {
    .Call(`_optimotu_mutual_information`, k, c, threads)
}

#' @rdname mutual_information
#' @export
adjusted_mutual_information <- function(k, c, threads = 1L) {
    .Call(`_optimotu_adjusted_mutual_information`, k, c, threads)
}

pairwise_alignment <- function(a, b, dist_config, span = 0L) {
    .Call(`_optimotu_pairwise_alignment`, a, b, dist_config, span)
}

#' @describeIn pairwise_alignment Compute pairwise global alignment CIGAR with WFA2
#' @export
#' @keywords internal
cigar_wfa2_global <- function(a, b, match = 0L, mismatch = 1L, gap_open = 0L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 1L) {
    .Call(`_optimotu_cigar_wfa2_global`, a, b, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2)
}

#' @describeIn pairwise_alignment Compute pairwise extension alignment CIGAR with WFA2
#' @export
#' @keywords internal
cigar_wfa2_extend <- function(a, b, match = 0L, mismatch = 1L, gap_open = 0L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 1L) {
    .Call(`_optimotu_cigar_wfa2_extend`, a, b, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2)
}

#' @describeIn pairwise_alignment Compute pairwise global alignment CIGAR with Edlib
#' @export
#' @keywords internal
cigar_edlib_global <- function(a, b) {
    .Call(`_optimotu_cigar_edlib_global`, a, b)
}

#' @describeIn pairwise_alignment Compute pairwise extension alignment CIGAR with Edlib
#' @export
#' @keywords internal
cigar_edlib_extend <- function(a, b) {
    .Call(`_optimotu_cigar_edlib_extend`, a, b)
}

#' @describeIn pairwise_alignment Compute pairwise alignment distance with WFA2
#' @export
#' @keywords internal
align_wfa2_global <- function(a, b, match = 0L, mismatch = 1L, gap_open = 0L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 0L) {
    .Call(`_optimotu_align_wfa2_global`, a, b, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2)
}

#' @describeIn pairwise_alignment Compute pairwise alignment distance with WFA2
#' @export
#' @keywords internal
align_wfa2_extend <- function(a, b, match = 0L, mismatch = 1L, gap_open = 0L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 0L) {
    .Call(`_optimotu_align_wfa2_extend`, a, b, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2)
}

#' @describeIn pairwise_alignment Compute pairwise  global alignment distance with Edlib
#' @export
#' @keywords internal
align_edlib_global <- function(a, b) {
    .Call(`_optimotu_align_edlib_global`, a, b)
}

#' @describeIn pairwise_alignment Compute pairwise extension alignment distance with Edlib
#' @export
#' @keywords internal
align_edlib_extend <- function(a, b) {
    .Call(`_optimotu_align_edlib_extend`, a, b)
}

#' Add gap statistics to a DataFrame containing CIGAR strings
#' @param df (DataFrame) containing a column with CIGAR strings
#' @param cigar_column (character) name of the column containing the CIGAR strings
#' @return (DataFrame) with the added gap statistics
#' @keywords internal
add_gapstats <- function(df, cigar_column) {
    .Call(`_optimotu_add_gapstats`, df, cigar_column)
}

#' @param match (`integer` scalar) score for a match, default: 1
#' @param mismatch (`integer` scalar) score for a mismatch, default: 2
#' @param gap_open (`integer` scalar) score for opening a gap, default: 10
#' @param gap_extend (`integer` scalar) score for extending a gap, default: 1
#' @param gap_open2 (`integer` scalar) alternate score for opening a gap,
#' default: 0
#' @param gap_extend2 (`integer` scalar) alternate score for extending a gap,
#' default: 0
#' @param prealign (`logical` flag) if `TRUE`, do a prealignment using
#' edit-distance as alignment score (`match = 0, mismatch = 1, gap_open = 0,
#' gap_extend = 1, gap_open2 = 0, gap_extend2 = 1`) to test feasibility before
#' aligning with alternate alignment scores. Note that, since pairwise distance
#' is defined using edit distance, any other set of scores will always result
#' in a pairwise distance which is equal to or greater than an alignment based
#' on the edit distance score.
#' @export
#' @rdname seq_distmx
seq_distmx_wfa2 <- function(seq, dist_threshold, match = -1L, mismatch = 2L, gap_open = 10L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 0L, prealign = TRUE, constrain = TRUE, threads = 1L) {
    .Call(`_optimotu_seq_distmx_wfa2`, seq, dist_threshold, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2, prealign, constrain, threads)
}

seq_cluster_single <- function(seq, dist_config, threshold_config, clust_config, parallel_config, output_type = "matrix", verbose = 0L) {
    .Call(`_optimotu_seq_cluster_single`, seq, dist_config, threshold_config, clust_config, parallel_config, output_type, verbose)
}

seq_cluster_multi <- function(seq, which, dist_config, threshold_config, clust_config, parallel_config, output_type = "matrix", verbose = 0L) {
    .Call(`_optimotu_seq_cluster_multi`, seq, which, dist_config, threshold_config, clust_config, parallel_config, output_type, verbose)
}

#' Search for best match(es) of query sequences in reference sequences
#'
#' @param seq (named `character`) sequences
#' @param dist_config (`optimotu_dist_config`) distance configuration
#' @param parallel_config (`optimotu_parallel_config`) parallelization
#' configuration. Search methods do not treat the different methods differently;
#' only the number of threads is used.
#' @param threshold (`numeric`) distance threshold for the search; larger
#' distances are not considered
#' @param verbose (`integer`) verbosity level
#' @param details (`integer`) detail level; 0 = score only, 1 = score and gap
#' stats, 2 = score and cigar
#' @param span (`integer`) alignment span
#' @return `data.frame` with columns `seq_id1` (first sequence ID),
#' `seq_id2` (second sequence ID), `score1` and `score2` (optimal alignment
#' score for the two sequences in the "prealignment" (if any) and "alignment"
#' stages), `dist1` and `dist2` (corresponding sequence distances). If
#' `details` is 1, also includes columns `align_length`, `n_insert`,
#' `n_delete`, `max_insert`, and `max_delete`. If `details` is 2, also
#' includes column `cigar`.
#' @keywords internal
seq_distmx_internal <- function(seq, dist_config, parallel_config, threshold, verbose = 0L, details = 0L, span = 0L, constrain = TRUE) {
    .Call(`_optimotu_seq_distmx_internal`, seq, dist_config, parallel_config, threshold, verbose, details, span, constrain)
}

#' @export
#' @rdname seq_distmx
seq_distmx_hamming <- function(seq, dist_threshold, min_overlap = 0L, ignore_gap = FALSE, threads = 1L, verbose = 0L) {
    .Call(`_optimotu_seq_distmx_hamming`, seq, dist_threshold, min_overlap, ignore_gap, threads, verbose)
}

#' Search for best match(es) of query sequences in reference sequences
#' @param query (named `character`) query sequences
#' @param ref (named `character`) reference sequences
#' @param dist_config (`optimotu_dist_config`) distance configuration
#' @param parallel_config (`optimotu_parallel_config`) parallelization
#' configuration. Search methods do not treat the different methods differently;
#' only the number of threads is used.
#' @param threshold (`numeric`) distance threshold for the search; larger
#' distances are not considered
#' @param verbose (`integer`) verbosity level
#' @return `data.frame` with columns `seq_id` (query sequence ID),
#' `ref_id` (reference sequence ID), and `dist` (distance between the query
#' and reference sequences)
#' @export
#' @keywords internal
seq_search_internal <- function(query, ref, dist_config, parallel_config, threshold, verbose = 0L, return_cigar = FALSE, span = 0L) {
    .Call(`_optimotu_seq_search_internal`, query, ref, dist_config, parallel_config, threshold, verbose, return_cigar, span)
}

#' Summarize taxonomic ranks by superordinate rank
#' @param data ('data.frame') the taxonomy to summarize; should contain a
#' column named `seq_id` and columns for each value of `ranks`
#' @param ranks ('character') the ranks to summarize
#' @return a data frame with columns:
#'
#'  - `supertaxon` (`character`) the superordinate taxon
#'  - `superrank` (`character`) the rank of the superordinate taxon
#'  - `rank` (`character`) the rank being summarized
#'  - `n_taxa` (`integer`) the number of unique taxa at the rank
#'  - `n_seq` (`integer`) the number of sequences
#'  - `seq_id` (`list` of `character`) a list of sequence IDs
#'  - `true_parition` (`list` of `integer`) integer mapping to taxa for each
#'     element in `seq_id`
#' @keywords internal
#' @export
summarize_by_rank <- function(data, ranks) {
    .Call(`_optimotu_summarize_by_rank`, data, ranks)
}

