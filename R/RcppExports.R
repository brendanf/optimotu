# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
single_linkage_hybrid_uniform <- function(seq, dmin, dmax, dstep, breakpoint = 0.1, method = "matrix", parallelism = "concurrent", threads = 1L, do_binary_search = FALSE, fill_method = 1L) {
    .Call(`_optimotu_single_linkage_hybrid_uniform`, seq, dmin, dmax, dstep, breakpoint, method, parallelism, threads, do_binary_search, fill_method)
}

#' @export
single_linkage_hybrid_array <- function(seq, thresholds, breakpoint = 0.1, method = "matrix", parallelism = "concurrent", threads = 1L, do_binary_search = FALSE, fill_method = 1L) {
    .Call(`_optimotu_single_linkage_hybrid_array`, seq, thresholds, breakpoint, method, parallelism, threads, do_binary_search, fill_method)
}

#' @export
single_linkage_hybrid_cached <- function(seq, thresholds, precision, breakpoint = 0.1, method = "matrix", parallelism = "concurrent", threads = 1L, do_binary_search = FALSE, fill_method = 1L) {
    .Call(`_optimotu_single_linkage_hybrid_cached`, seq, thresholds, precision, breakpoint, method, parallelism, threads, do_binary_search, fill_method)
}

#' Confusion matrix for a set of "test" partitions vs. a "true" partition
#'
#' One way to analyze the comparison of two different partitions of the same
#' data is to treat it as a binary classification problem operating on pairs
#' of objects, where pairs should be classified as belonging to the same
#' cluster or not.  Then a "true positive" is a pair which belong to the same
#' cluster in both the "test" partition and the "true" partition; a "false
#' positive" is a pair which belongs to the same cluster in the "test"
#' partition but not the "true" partition; a "false negative" is a pair which
#' belongs to the same cluster in the "true" partition but not in the "test"
#' partition; and a "true" negative is a pair which does not belong to the same
#' cluster in either the "test" partition or the "true" partition.
#'
#' This formulation allows various measures of binary classification
#' performance to be applied to the case of clustering.
#'
#' @return (`data.frame` with `m` rows) for each "test" partition, the number
#' of true positives ("`TP`"), false positives ("`FP`"), false negatives
#' ("`FN`"), and true negatives ("`TN`") relative to the "true" partition.
#'
#' @export
#' @inheritParams mutual_information
confusion_matrix <- function(k, c, threads = 1L) {
    .Call(`_optimotu_confusion_matrix`, k, c, threads)
}

distmx_cluster_single <- function(file, seqnames, threshold_config, method_config, parallel_config, output_type = "matrix") {
    .Call(`_optimotu_distmx_cluster_single`, file, seqnames, threshold_config, method_config, parallel_config, output_type)
}

distmx_cluster_multi <- function(file, seqnames, which, threshold_config, method_config, parallel_config, output_type = "matrix") {
    .Call(`_optimotu_distmx_cluster_multi`, file, seqnames, which, threshold_config, method_config, parallel_config, output_type)
}

#' @export
distmx_edlib <- function(seq, dist_threshold, constrain = TRUE, threads = 1L) {
    .Call(`_optimotu_distmx_edlib`, seq, dist_threshold, constrain, threads)
}

#' @export
distmx_hybrid <- function(seq, dist_threshold, breakpoint = 0.1, threads = 1L) {
    .Call(`_optimotu_distmx_hybrid`, seq, dist_threshold, breakpoint, threads)
}

#' Size of the intersection between two sorted sets
#'
#' This implementation is much faster that `length(intersect(c, k))`. However
#' it assumes (without checking!) that the sets are sorted.
#'
#' @param c (sorted `integer` or ` character` vector) the first set to compare
#' @param k (sorted `integer` or ` character` vector) the second set to compare
#'
#' @return (`integer` count) the number of elements which occur in both sets
#' @export
intersect_length <- function(c, k) {
    .Call(`_optimotu_intersect_length`, c, k)
}

#' @export
#' @rdname intersect_length
intersect_length_string <- function(c, k) {
    .Call(`_optimotu_intersect_length_string`, c, k)
}

inner_fmeasure <- function(cj, kpartition, nk) {
    .Call(`_optimotu_inner_fmeasure`, cj, kpartition, nk)
}

fmeasure_list <- function(k, c, ncpu = 1L) {
    .Call(`_optimotu_fmeasure_list`, k, c, ncpu)
}

fmeasure_matrix <- function(k, c, ncpu = 1L) {
    .Call(`_optimotu_fmeasure_matrix`, k, c, ncpu)
}

#' @export
distmx <- function(seq, dist_threshold, udist_threshold, match = 1L, mismatch = 2L, gap_open = 10L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 0L, threads = 1L) {
    .Call(`_optimotu_distmx`, seq, dist_threshold, udist_threshold, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2, threads)
}

#' Calculate similarity for a set of alternate "test" partitions vs. a "true" partition
#'
#' @param k (`m` x `n` `integer` matrix) `m` alternative "test" partitions; each
#' row gives the cluster assignment for the `n` objects. Objects with the same
#' cluster ID are clustered together. Cluster IDs do not need to be
#' consecutive, and they do not need to correspond between different
#' partitions.
#' @param c (`integer` vector of length `n`) "True" partition of the `n`
#' objects.
#' @param threads (`integer` count) number of parallel threads to use.
#'
#' @return (`numeric` vector of length `m`) The similarity measure between each
#' of the alternative partitions and the "true" partition.
#' @export
mutual_information <- function(k, c, threads = 1L) {
    .Call(`_optimotu_mutual_information`, k, c, threads)
}

#' @rdname mutual_information
#' @export
adjusted_mutual_information <- function(k, c, threads = 1L) {
    .Call(`_optimotu_adjusted_mutual_information`, k, c, threads)
}

cigar_wfa2 <- function(a, b, match = 0L, mismatch = 1L, open1 = 0L, extend1 = 1L, open2 = 0L, extend2 = 1L) {
    .Call(`_optimotu_cigar_wfa2`, a, b, match, mismatch, open1, extend1, open2, extend2)
}

cigar_edlib <- function(a, b) {
    .Call(`_optimotu_cigar_edlib`, a, b)
}

#' @export
#'
align <- function(a, b, match = 0L, mismatch = 1L, gap = 1L, extend = 0L, gap2 = 0L, extend2 = 0L) {
    .Call(`_optimotu_align`, a, b, match, mismatch, gap, extend, gap2, extend2)
}

#' @export
distmx_prealign <- function(seq, dist_threshold, match = 1L, mismatch = 2L, gap_open = 10L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 0L, prealign = TRUE, constrain = TRUE, threads = 1L) {
    .Call(`_optimotu_distmx_prealign`, seq, dist_threshold, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2, prealign, constrain, threads)
}

#' @export
distmx_snsn <- function(seq, dist_threshold, match = 1L, mismatch = 2L, gap_open = 10L, gap_extend = 1L, gap_open2 = 0L, gap_extend2 = 0L, constrain = TRUE, threads = 1L) {
    .Call(`_optimotu_distmx_snsn`, seq, dist_threshold, match, mismatch, gap_open, gap_extend, gap_open2, gap_extend2, constrain, threads)
}

